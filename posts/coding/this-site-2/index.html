<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>How this Site is Built</title><link rel="stylesheet" type="text/css" href="/main-6c76d.css" /><link rel="shortcut icon" href="/favicon.png" /><link rel="manifest" href="/manifest.webmanifest" /><meta name="theme-color" content="#00D1B2" /></head><body><div class="container"><div class="column is-8 is-offset-2"><nav class="breadcrumb is-marginless is-centered" aria-label="breadcrumbs"><ul><li class><a href="/">Home</a></li><li class><a href="/posts">Posts</a></li><li class><a href="/posts/coding">Coding</a></li><li class="is-active"><a href="/posts/coding/this-site-2">This Site 2</a></li></ul></nav><div class="section titles-section"><h1 class="title is-2">How this Site is Built</h1><span class="has-text-grey"><time dateTime="2019-08-10">August 10, 2019</time> Â· 5 min read</span></div><div id="content" class="content is-medium"><h1>RIP Gatsby</h1><p>I ditched Gatsby.</p><figure><img src="gatsby-gets-shot.jpg" alt="Death to gatsby" /><figcaption>Gatsby is dead.</figcaption></figure><p>I decided to ditch Gatsby because after <a href="https://github.com/gatsbyjs/gatsby/pull/14889">an update to how Gatsby's resources were loaded,</a> my site wouldn't build anymore.
I could just use an old version of Gatsby forever, but even with the old version things were breaking because of dependencies of Gatsby's dependencies in its <a href="https://github.com/gatsbyjs/gatsby/blob/master/package.json">package.json</a> (welcome to the NPM ecosystem).
I didn't want to my entire project's to hinge on a single <inlineCode>package-lock.json</inlineCode>, so I decided to write my own framework.</p><h2>Death to Webpack, too</h2><p>Webpack is a little black box everyone depends on.</p><figure><img src="webpack.png" alt="Webpack" /><figcaption>Most web developers use this. Most don't have the slightest idea how it works.</figcaption></figure><p>I like Webpack, so I experimented with building my site using <a href="https://github.com/GoogleChromeLabs/prerender-loader">prerender-loader</a> or <a href="https://github.com/chrisvfritz/prerender-spa-plugin">prerender-SPA-plugin</a> paired with <a href="https://github.com/preactjs/preact-router">Preact-router</a>.
I never want to actually use a router since I have to update it every post, but it was bearable and I could dynamically generate routes based on <a href="https://github.com/isaacs/node-glob">globbing</a> my local directories.</p><p>There were a lot of small annoying problems I ran into with prerendering (like needing React AND Preact).
The real problem ended up being I had to use the same bloated JS to generate the static HTML as I bundled in the page. This includes things I never want to ship in my bundle like <a href="https://github.com/download/preact-helmet">preact-helmet</a>. There was the issue of dynamically templating some pages to NOT include JS...</p><p>Suffice it to say it got complicated FAST (I'd have to run webpack twice -- once to prerender, and once to bundle) so I gave up on a Webpack approach.
I briefly checked out <a href="https://github.com/parcel-bundler/parcel">Parcel</a> but it seems that the <em>approach</em> is flawed more than the tools. Bundlers are made for SPAs.</p><h2>What I actually want</h2><figure><svg id="preact-logo" width="100%" viewBox="-256 -286 1820 572" style="background: #673ab8;"><path style="transition:all 1s ease; transform:rotate(0deg);" fill="white" d="M0,-256 221.7025033688164,-128 221.7025033688164,128 0,256 -221.7025033688164,128 -221.7025033688164,-128z"></path><ellipse cx="0" cy="0" stroke-dasharray="387 60" stroke-dashoffset="0" stroke-width="16px" rx="75px" ry="196px" fill="none" stroke="#673ab8" transform="rotate(52)"></ellipse><ellipse cx="0" cy="0" stroke-dasharray="387 60" stroke-dashoffset="0" stroke-width="16px" rx="75px" ry="196px" fill="none" stroke="#673ab8" transform="rotate(-52)"></ellipse><circle cx="0" cy="0" r="34" fill="#673ab8"></circle><path fill="white" d="M289.85 25.25L289.85 125L272 125L272-122.63L335.88-122.63Q379.45-122.63 401.59-103.55Q423.73-84.48 423.73-49.13Q423.73-32.85 417.69-19.20Q411.65-5.55 400.27 4.34Q388.90 14.22 372.63 19.74Q356.35 25.25 335.88 25.25L289.85 25.25M289.85 10.90L335.88 10.90Q352.33 10.90 365.27 6.35Q378.23 1.80 387.24-6.25Q396.25-14.30 401.06-25.24Q405.88-36.18 405.88-49.13Q405.88-77.65 388.29-93.05Q370.70-108.45 335.88-108.45L289.85-108.45L289.85 10.90ZM497.58 13.00L497.58 125L479.73 125L479.73-122.63L542.90-122.63Q585.78-122.63 606.95-106.09Q628.13-89.55 628.13-57.53Q628.13-43.35 623.23-31.63Q618.33-19.90 609.14-11.06Q599.95-2.23 587 3.46Q574.05 9.15 557.78 10.90Q561.98 13.52 565.30 17.90L650.53 125L634.95 125Q632.15 125 630.14 123.95Q628.13 122.90 626.20 120.45L546.93 20.00Q543.95 16.15 540.54 14.57Q537.13 13.00 529.95 13.00L497.58 13.00M497.58-0.30L540.63-0.30Q557.08-0.30 570.11-4.24Q583.15-8.18 592.16-15.53Q601.18-22.88 605.90-33.20Q610.63-43.53 610.63-56.48Q610.63-82.90 593.30-95.68Q575.98-108.45 542.90-108.45L497.58-108.45L497.58-0.30ZM843.73-122.63L843.73-107.75L713.35-107.75L713.35-7.65L821.85-7.65L821.85 6.87L713.35 6.87L713.35 110.13L843.73 110.13L843.73 125L695.33 125L695.33-122.63L843.73-122.63ZM1088.55 125L1074.73 125Q1072.28 125 1070.70 123.69Q1069.13 122.38 1068.25 120.28L1039.03 48.35L917.40 48.35L888.35 120.28Q887.65 122.20 885.90 123.60Q884.15 125 881.70 125L868.05 125L969.38-122.63L987.23-122.63L1088.55 125M922.83 35.05L1033.78 35.05L983.20-90.08Q981.98-93.05 980.75-96.81Q979.53-100.58 978.30-104.78Q977.08-100.58 975.85-96.81Q974.63-93.05 973.40-89.90L922.83 35.05ZM1302.40 83.35Q1304.15 83.35 1305.38 84.57L1312.38 92.10Q1304.67 100.33 1295.58 106.89Q1286.47 113.45 1275.71 118.09Q1264.95 122.72 1252.09 125.26Q1239.22 127.80 1223.83 127.80Q1198.10 127.80 1176.66 118.79Q1155.22 109.78 1139.91 93.24Q1124.60 76.70 1116.03 53.25Q1107.45 29.80 1107.45 1.10Q1107.45-27.08 1116.29-50.35Q1125.13-73.63 1141.14-90.34Q1157.15-107.05 1179.46-116.24Q1201.78-125.43 1228.72-125.43Q1242.20-125.43 1253.40-123.41Q1264.60-121.40 1274.31-117.64Q1284.03-113.88 1292.60-108.28Q1301.17-102.68 1309.40-95.33L1303.97-87.45Q1302.58-85.35 1299.60-85.35Q1298.03-85.35 1295.58-87.19Q1293.13-89.03 1289.36-91.74Q1285.60-94.45 1280.26-97.69Q1274.92-100.93 1267.58-103.64Q1260.22-106.35 1250.60-108.19Q1240.97-110.03 1228.72-110.03Q1206.15-110.03 1187.25-102.24Q1168.35-94.45 1154.70-80.01Q1141.05-65.58 1133.44-45.01Q1125.83-24.45 1125.83 1.10Q1125.83 27.35 1133.35 48.00Q1140.88 68.65 1154.17 82.91Q1167.47 97.17 1185.59 104.79Q1203.70 112.40 1224.88 112.40Q1238.17 112.40 1248.59 110.65Q1259 108.90 1267.75 105.40Q1276.50 101.90 1284.03 96.82Q1291.55 91.75 1298.90 84.92Q1299.78 84.22 1300.56 83.79Q1301.35 83.35 1302.40 83.35ZM1530.42-122.63L1530.42-107.40L1443.45-107.40L1443.45 125L1425.60 125L1425.60-107.40L1338.10-107.40L1338.10-122.63L1530.42-122.63Z"></path></svg><figcaption>I just want to use Preact as much as I can.</figcaption></figure><p>Since my pages don't include JS, I really just want a templating framework, like <a href="https://hexo.io">hexo</a> or <a href="https://gohugo.io">hugo</a> to render my site's HTML.
However, I want to write React components in JSX instead of EJS or <inlineCode>%</inlineCode>-style PHP templates. For example, I already had the <a href="https://github.com/thesmartwon/thesmartwon.com/blob/master/src/templates/post-template.js">post template</a>, <a href="https://github.com/thesmartwon/thesmartwon.com/blob/master/src/components/article-preview.js">article previews</a>, and the <a href="https://github.com/thesmartwon/thesmartwon.com/blob/master/src/components/breadcrumb.js">breadcrumb</a> written in React,.</p><figure><pre><code class="language-js">{posts.map(post =&gt; ArticlePreview(post))}
</code></pre><figcaption>This is all I write for Article previews on navigation pages. No copy/pasting and updating per-post.</figcaption></figure><p>Using React as my templating engine makes it easy for when I want to write JS for things like my <a href="/posts/money/early-retirement">retirement calculator</a>. I can just keep using React.</p><h1>Back to the basics</h1><p>I needed to render my components to HTML using something like <a href="https://github.com/preactjs/preact-render-to-string">preact-render-to-string</a>.
Rendering React components per-markdown file seems like such a simple use case, yet no other frameworks seemed to have me covered.</p><p>To get started using <inlineCode>preact-render-to-string</inlineCode>, I needed a bit of hackery using <a href="https://babeljs.io/docs/en/babel-register">@babel/register</a>:</p><pre><code class="language-js">const path = require('path')
const fs = require('fs-extra')
const mime = require('mime')
const render = require('preact-render-to-string')
const { h } = require('preact')
// Hack to hijack all require()s and babel them
require('@babel/register')({
  ignore: [/node_modules/],
  plugins: [
    ['@babel/plugin-transform-react-jsx', { pragma: 'h' }, ],
    ['@babel/plugin-proposal-class-properties']
  ],
  presets: ['@babel/preset-env']
})

// All further `require()`s go through Babel (so they can 
// include JSX, class properties, and `import` statements)
const { myComponent } = require('some-component');
console.log(render(h(myComponent)))
</code></pre><p>After figuring out <a href="https://github.com/preactjs/preact-render-to-string">preact-render-to-string</a> was something I could use with JSX without having to have extra intermediate files, I was SOLD!!</p><figure><img src="shut-up-and-take-my-money.jpg" alt="Take my money" /><figcaption>Shut up and take my soul.</figcaption></figure><h2>Let's commit to this renderer</h2><p>I need to extract some metadata from Markdown files (like the post's title and date) to include in my templated site components (like the <a href="https://github.com/thesmartwon/thesmartwon.com/blob/master/src/templates/post-template.js">post template</a>). <a href="https://github.com/unifiedjs/unified">Unified</a> is THE natural choice for this in NodeJS land.</p><h3>Enter: MDX</h3><p>I also wanted to be able to include React components in my Markdown files so dynamic components can be statically rendered like the <a href="/posts/money/early-retirement">retirement calculator</a>. Enter <a href="https://mdxjs.com/">MDX</a>, which has a plugin for Unified called <a href="https://github.com/mdx-js/mdx/tree/master/packages/remark-mdx">remark-mdx</a>.</p><figure><svg xmlns="http://www.w3.org/2000/svg" width="138" height="57"><g fill="none" fill-rule="evenodd"><rect width="136.5" height="55.5" x=".75" y=".75" fill="#FFF" stroke="#EAEAEA" stroke-width="1.5" rx="4.5"></rect><g stroke="#000" stroke-width="6"><path stroke-linecap="square" d="M70.5 36V13.836"></path><path d="M57 27.239L70.611 40.85l13.415-13.414"></path></g><path stroke="#000" stroke-width="6" d="M16.45 43.928V18.964L30.3 32.815l13.932-13.931v24.865"></path><g stroke="#F9AC00" stroke-width="6"><path d="M122.439 41.268L93.17 12M93.561 41.268L122.83 12"></path></g></g></svg><figcaption>Pretty neat idea. Markdown -&gt; JSX.</figcaption></figure><p>I created a Unified pipeline that used <a href="https://github.com/mdx-js/mdx/tree/master/packages/remark-mdx">remark-mdx</a> like this:</p><pre><code class="language-js">const markdownPipe = require('unified')()
    .use(require('remark-parse'))
    // Frontmatter
    .use(require('remark-frontmatter'))
    .use(require('remark-parse-yaml'))
    .use(() =&gt; (ast, file) =&gt; {
        visit(ast, 'yaml', item =&gt; {
            file.data.frontmatter = item.data.parsedValue
            const { frontmatter } = file.data
            frontmatter.dateShort = moment(frontmatter.date).format('YYYY-MM-DD')
            frontmatter.dateLong = moment(frontmatter.date).format('MMMM DD, YYYY')
        });
    })
    .use(() =&gt; (ast, file) =&gt; {
        let { frontmatter } = file.data
        let excerpt = ''
        visit(ast, 'text', item =&gt; {
            excerpt += item.value + ' '
        })

        frontmatter.excerpt = excerpt.substr(0, 150).trim()
        // Assume 300wpm reading speed
        // Round to nearest .5
        frontmatter.timeToRead = Math.round(excerpt.split(' ').length / 300 * 2) / 2
    })
    // Render to JSX
    .use(require('remark-mdx'))
    .use(require('./mdx-ast-to-mdx-hast'))
    .use(require('./mdx-hast-to-jsx'))
</code></pre><p><a href="https://github.com/mdx-js/mdx/tree/master/packages/mdx">MDX's default way of rendering to JSX</a> wasn't exactly what I wanted, so I wrote my own <a href="https://github.com/thesmartwon/thesmartwon.com/blob/master/scripts/mdx-ast-to-mdx-hast.js">ast-to-mdx-hast</a> and <a href="https://github.com/thesmartwon/thesmartwon.com/blob/master/scripts/mdx-hast-to-jsx.js">mdx-hast-to-jsx</a> built on top of <a href="https://github.com/mdx-js/mdx/tree/master/packages/remark-mdx">remark-mdx</a>.</p><p>Now for each one of my Markdown files, I have a <inlineCode>.md.js</inlineCode> file that looks like this:</p><pre><code class="language-js">import { h, Fragment } from 'preact'

export default () =&gt; &lt;Fragment&gt;
  {/* Content here */}
&lt;/Fragment&gt;;
</code></pre><p>Now I just <inlineCode>require()</inlineCode> that file and use <a href="https://github.com/preactjs/preact-render-to-string">preact-render-to-string</a> on it!
I also collect some metadata on all the posts rendered in order to build index pages that list all the posts.</p><h3>But you need <em>some</em> JavaScript</h3><p>For interactive pages, I do need some JavaScript. Rollup played the role of Babelling, bundling, and minifying JS files like this:</p><pre><code class="language-js">import { h, render } from 'preact'
import { Logo } from '../../../src/components/logo'

const root = document.getElementById('preact-logo')
render(h(Logo), root, root)
</code></pre><p>The config is a little overly verbose, but it's not terrible:</p><pre><code class="language-js">rollup.rollup({
  input: file,
  plugins: [
    resolve(),
    babel({ exclude: 'node_modules/**' }),
    terser(),
  ],
}).then(bundle =&gt; bundle.generate({
    format: 'iife', // immediately invoked function expression
    name: slug.split('/').pop().replace(/\-/g, ''), // global variable name representing your bundle
    compact: true,
  }).then(({ output }) =&gt; console.log(output[0].code))
}))
</code></pre><p>The more annoying part is injecting the CSS and JS file names dynamically into the HTML templates. I just kept track of where I wrote out the CSS and JS files. For development, I don't bother changing the filename to include a hash because that's a lot of work.</p><h3>Orchestrating it all</h3><p>I used to have a single NodeJS script orchestrating all the tools, but I just decided to use <a href="https://gulpjs.com/">Gulp</a>, which is a nice task runner to read and write files at certain paths. The default task of <a href="https://github.com/thesmartwon/thesmartwon.com/blob/master/gulpfile.js">my Gulpfile</a>:</p><ul><li>Creates assets with no dependencies: parallel(copyStaticAssets, copyPostAssets, css, js)<ul><li>Populates cssFileNames = [] and jsFileNames = {}</li></ul></li><li>Renders posts (and populates posts = {} to pass to index pages)</li><li>Renders Pages</li><li>Cleans up a file that all posts that are drafts and shouldn't be rendered get pointed to</li></ul><h4>Creating the start task</h4><p>This is what Gulp made easy for me since I didn't use a pre-built framework with nice hot-reloading for me. Gulp wraps <a href="https://github.com/paulmillr/chokidar">chokidar's</a> <inlineCode>watch</inlineCode> function:</p><pre><code class="language-js">function start() {
    watch(paths.postAssets.src, { ignoreInitial: false }, copyPostAssets)
    watch(paths.staticAssets.src, { ignoreInitial: false }, copyStaticAssets)

    // TODO: parallel css/js
    css()
        .on('end', () =&gt; js() // TODO: rollup.watch
            .on('end', () =&gt; {
                watch(paths.sass.src, css)
                watch(jsWatchFiles, js)
                watch(paths.posts.src, { ignoreInitial: false }, series(renderPosts, renderPages))
                watch(paths.pages.src, { ignoreInitial: false }, renderPages)
            })
        )
}
</code></pre><p>I do still have to reload my page manually after my site rebuilds, but I could look into using <a href="https://www.browsersync.io/docs/gulp">browser-sync</a> to auto-reload it. That would also save me having <a href="https://www.npmjs.com/package/http-server">http-server</a> open in another terminal serving my <inlineCode>dist</inlineCode> folder.</p><h2>Reflection</h2><p>All this work took me upwards of 25 hours. The hardest part was writing the remark plugins for MDX. A lot of it was wasted researching prerendering, and I did write a few posts in the meantime.</p><p>It was well worth it to control every tool that creates the HTML, CSS, and JS my readers read. I'm (fairly) framework agnostic and learned a ton of new things! </p><h1>Future work</h1><p>My hot-reloading development workflow still needs a few changes:</p><ul><li>Node-sass as well as Rollup have their own watch functions, so I should use those.</li><li>On changes to my component templates, all pages should reload and we need to re-require the module. Currently nothing happens.</li></ul><p>My production environment also needs a few fixes:</p><ul><li>I need to minimize my images and wrap them in a container to avoid the content changing height once loaded. I also need to use <inlineCode>srcset</inlineCode> for responsive images. I'd also like a nicer way to create centered images for posts than having to write all this each time:</li></ul><pre><code class="language-html">&lt;figure&gt;
  &lt;img src=&quot;shut-up-and-take-my-money.jpg&quot; alt=&quot;Take my money&quot; /&gt;
  &lt;figcaption&gt;Shut up and take my soul.&lt;/figcaption&gt;
&lt;/figure&gt;
</code></pre><ul><li>I need a way to separate out my Preact dependency so it doesn't have to reload 4kb on every JS page.</li></ul></div><div class="has-text-centered"><a href="#">Back to top</a> / <a href="/posts">View all posts</a></div></div></div><script src="index-2c644.js"></script></body></html>